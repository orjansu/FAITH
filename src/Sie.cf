-- Language to parse the proof script. Not to parse rules.

entrypoints ProofScript;

DProofScript. ProofScript ::= ProgBindings [Theorem];

DProgBindings. ProgBindings ::= "bindings" "{" [ProgBinding] "}";
terminator ProgBinding ";";

DProgBinding. ProgBinding ::= CapitalIdent "=" LetBindings;

token CapitalIdent (upper letter*);

comment "--";
comment "{-" "-}";

--------------- Terms ------------------------------

LBSAny.   LetBindings ::= "?";
LBSVar.   LetBindings ::= CapitalIdent;
LBSSet.   LetBindings ::= "<" [LetBinding] ">";
separator LetBinding ",";

LBAny.      LetBinding ::= "?";
LBConcrete. LetBinding ::= Var BindSymbol Term;

BSWeights.  BindSymbol ::= "=[" StackWeight "," HeapWeight "]=";
BSNoWeight. BindSymbol ::= "=";

StackWeightExpr. StackWeight ::= IntExpr;
HeapWeightExpr.  HeapWeight ::= IntExpr;

IEAny.   IntExpr1 ::= "?";
IEVar.   IntExpr1 ::= Ident;
IENum.   IntExpr1 ::= Integer;
IEPlus.  IntExpr  ::= IntExpr "+" IntExpr1;
IEMinus. IntExpr  ::= IntExpr "-" IntExpr1;
coercions IntExpr 1;

DRedWeight. RedWeight ::= "[" StackWeight "]";

TAny.             Term1 ::= "?";
TTermVar.         Term1 ::= "any" "(" CapitalIdent ")";
TNonTerminating.  Term1 ::= "@" ;
TVar.             Term1 ::= Var;
TIndVar.          Term  ::= Var "^" IndExpr;
TNum.             Term1 ::= Integer;
THole.            Term1  ::= "[.]";
-- Temporary. Might want to do separate grammar for contexts.
TConstructor.     Term  ::= Constructor;
TLam.             Term  ::= "\\" Var "." Term1 ;
TLet.             Term  ::= "let" LetBindings "in" Term1;
TStackSpike.      Term  ::= "s^" Term1;
TStackSpikes.     Term  ::= "["StackWeight"]s^" Term1;
THeapSpike.       Term  ::= "h^" Term1;
THeapSpikes.      Term  ::= "["HeapWeight"]h^" Term1;
TDummyBinds.      Term  ::= VarSet "d^" Term1;
TRedWeight.       Term  ::= RedWeight "(" Red ")";
TRed.             Term  ::= Red;

RCase.       Red ::= "case" Term "of" "<" [CaseStm] ">";
RApp.        Red ::= Term Var;
RAddConst.   Red ::= "add" Integer Term1;
RIsZero.     Red ::= "iszero" Term1;
RSeq.        Red ::= "seq" Term1 Term1 ;
RPlusWeight. Red ::= Term "+" RedWeight Term1;
RPlus.       Red ::= Term "+" Term1;

coercions Term 3;

DIndExpr. IndExpr ::= IntExpr1;
CGeneral. Constructor ::= CapitalIdent "(" [Var] ")";
CCons. Constructor ::= Var ":" Var;
CTrue. Constructor ::= "true";
CFalse. Constructor ::= "false";
DVar. Var ::= Ident;
separator Var "";
DVarSet. VarSet ::= "<" [Var] ">"; -- variables are separated by space.

separator CaseStm ",";
CSConcrete. CaseStm ::= Constructor "->" Term;

--------------- Theorem --------------------

DTheorem.     Theorem ::= Proposition Proof;
separator Theorem "";
DProposition. Proposition ::= "proposition" ":" InContext Free "|-" Term ImpRel Term ";";
DQed.         Qed ::= "qed";

PByFPInduction.   Proof ::= "proof" ":" "-fix-point-induction" Var
                            "-base" "{" [ProofStep] "}"
                            "-induction" "{" [ProofStep] "}" Qed ";" ;
PStraightForward. Proof ::= "proof" ":" "-simple"
                            "-single" "{" [ProofStep] "}" Qed ";" ;
PGeneral.         Proof ::= "proof" ":" CommandName [CmdArgument]
                            [SubProof] Qed ";";

WithContext. InContext ::= CapitalIdent;
NoContext.   InContext ::= ;

WithFree. Free ::= "free" "(" [VarAnyType] ")" ;
NoFree.   Free ::= ;

DefinedEqual.        ImpRel ::= "=def=";
StrongImprovementLR. ImpRel ::= "|~>";
WeakImprovementLR.   ImpRel ::= "|~~>";
StrongImprovementRL. ImpRel ::= "<~|";
WeakImprovementRL.   ImpRel ::= "<~~|";
StrongCostEquiv.     ImpRel ::= "<~>";
WeakCostEquiv.       ImpRel ::= "<~~>";

token CommandName ('-' (letter | '@' ) (letter | '-' | '@' | digit| '\'')*);
-- copied to SieLaws

CAValue.          CmdArgument ::= CmdValue;
CAAssign.         CmdArgument ::= CmdAssignee "=" CmdValue ;
CVTermOrCtx.      CmdValue    ::= Term1;
CVLetBindings.    CmdValue    ::= "let" LetBindings;
CVVarSet.         CmdValue    ::= VarSet;
CASmallVar.       CmdAssignee ::= VarAnyType;
CADummySet.       CmdAssignee ::= "<" CapitalIdent ">";

BigVar.   VarAnyType ::= Ident;
SmallVar. VarAnyType ::= CapitalIdent;
separator VarAnyType " ";

separator CmdArgument " ";

DSubProof. SubProof ::= CommandName "{" [ProofStep] "}";
separator SubProof "";

PSCmd.         ProofStep ::= "on" SubTerm TransCmd;
PSFirstTerm.   ProofStep ::= Term;
PSTerm.        ProofStep ::= ImpRel Term;
PSHereMarker.  ProofStep ::= "$";
PSQed.         ProofStep ::= Qed;
terminator ProofStep ";";

CmdSpecial. TransCmd ::= SpecialTransCmd;
CmdGeneral. TransCmd ::= CommandName [CmdArgument];

STWholeWithCtx. SubTerm ::= "whole";
STShown.        SubTerm ::= "shown";
STTerm.  SubTerm ::= Term1;
STGuess. SubTerm ::= "guess";

STCAlphaEquiv.  SpecialTransCmd ::= "-alpha-equiv";
STCReorderCase. SpecialTransCmd ::= "-reorder-case" "(" [Var] ")";
STCReorderLet.  SpecialTransCmd ::= "-reorder-let" "(" [Var] ")";
