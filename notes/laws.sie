reserved-letters{
G :: LetBindings,
V :: Value,
C, D :: Context,
v, w, n, m, i, j :: Integer,
x, y :: Var,
Vctx :: ValueContext,
X :: DummyBindings, -- Set(Var)
R :: Reduction,
M, N :: Term
}
-- Detta börjar likna ott rätt så rejält.
-- Testa att försöka uttrycka detta i Ott, och se vad det ger.

unfold-1: let G {x =[v,w]= V} in C[x] |~> let G {x =[v,w]= V} in C[{x}d^V].
unfold-2: let G {x =[v,w]= V} in C[x] <~| let G {x =[v,w]= V} in C[{x}d^[v]s^V].
unfold-3: let G {x =[v,w]= V} in C[x] <~> let G {x =[v,w]= V} in C[[v]s^V]
                                                 if x in FV(V) .
unfold-4: let G {x =[0,w]= V} in C[x] <~> let G {x =[0,w]= V} in C[{x}d^V].
unfold-5: let G {x =[0,0]= V} in C[x] <~> let G {x =[0,0]= V} in C[V].


R-case: [w]R[[v]case M of {pat_i -> N_i}]
    <~> [w+v]case M of {pat_i -> [w]R[N_i]}.

value-merge: let G {x = V, y = V} in M |~> let G[x/v] {x = V[x/y]} in M[x/y].
value-merge': let G {x = let {y = V} in V} in M
          |~> let G {x = V[x/y]} in M.
value-copy:  let G {x = V, y = V} in M
         <~| let G[x/v] {x =[1,2]= V[x/y]} in M[x/y].

case-fold: let{x =[v,w]= M} in C[case x of {alts, c ys -> D[{x}d^[v]s^c ys]
       |~> let{x =[v,w]= M} in C[case x of {alts, c ys -> D[x]}].



def-unwindings-base: let {f =[w,v]= Vctx[f]} in C[f^0]
               =def= let {f =[w,v]= Vctx[f]} in C[{f}d^¤].
def-unwindings-induction: let {f =[w,v]= Vctx[f]} in C[f^(n+1)]
                    =def= let {f =[w,v]= Vctx[f]} in C[[w]s^Vctx[f^n]].

dummy-ref-algebra-8: {X}d^M |~> M.
¤-rules-1: {X}d^¤ |~> M            if FV(M) subsetof X.
¤-rules-3: R[¤] <~> {FV(R)}d^¤.
spike-algebra-zero-stack-spike: [0]s^M <~> M
spike-algebra-13: [w]s^M |~> M
reduction: [w]R[V] <~> [w]s^{X}d^N if (R[V] ~~> N) && (FV(R[V]) = FV({X}d^N)).


reduction-beta: (\x. M) y ~~> M[x/y].
reduction-case: case c_j ys of {c_i xs_i -> M_i} ~~> M_j[ys/xs_j].
reduction-seq: seq V M ~~> M.
reduction-plus: m + [w]N ~~> [w]add m N. --tog bort parentes för behövs nog ej.
reduction-add: add m n ~~> <m + n>.
reduction-iszero-true: iszero 0 ~~> true.
reduction-iszero-false: iszero n ~~> false if n != 0.
