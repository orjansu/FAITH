konvertera när det inte finns viktnotation till att det är vikt 1,1
se till att bara reductions kan ha viktnotation - fixat tror jag
Se till att det är rätt uttryck som får ha wildcard och M
Kolla om man enkelt kan ändra pretty-printern. Annars ändra språket
så att det kan pretty-printas snyggt.

Language notes:
{} versus : qed.
"" eller $$ runt termer?
Stora bokstäver på keywords för att inte krocka med kommandon?
c y vs f x är bara vad variabelnamnen heter. Jag tror att man behöver stora
bokstäver för konstruktorer av den anledningen.
ev göra om så att man kan skriva [2] s^M, men jag gillar mer [2]s^M. se
THeapSpikes t.ex.
--------för att allt ska funka:
Konstruktorer behöver vara stor bokstav och parentes runt argument
-commandonamn måste börja med '-' - byt till camelcase
-lägg till minus.
-ta bort extra typ för stach/heap weight?
-Kolla Ident vs Var - Ha var hela tiden, så kan det skilja sig mellan
laws och inte om det är metavar eller inte?

x Kolla varningar/ambiguitet!

Language notes, laws:
R, C, D, V, W, M, N måste nog vara reserverade.
V används både som value och som kontext. Lösning nu: context är Vctx[]
bara här används alts
blir det förvirrande med [] både för contexts, listor och vikter? och även substitutioner [x/y]
hur göra generella vektorer \vec{y}?
  - y1...yn
  - ->y
  - [y]
  - ys
Jag tror att allt ska vara reserverat här, även variabler. På det viset kan vi
säga ys och liknande.
=def=
X kan nu vara ett set med variabler, istället för {x}.
  lösning: {X}d^. Det är ett set av set, men det blir konstigt annars, om man
  ska ha ex FV(R) däri.
~~> reduces to
eventuellt får vi göra åtminstone case-fallet på ~~> via en funktion. Det är
nog rätt krångligt att supporta alla varianter av språket man erbjuder om man
introducerar indexering. Ev kolla på Ott.
<m + n> är den faktiska additionen. Ev ändra syntax.
true :: Constructor
false :: Constructor
FV -- Term or context -> Set(Var). Del av syntax och ej variabel

Language notes, patternmatch:
bara här används "?"

Proofs:
Ide: om man vill kanske man kan ha en av variablerna från laws.sie här?
t.ex.
  on "s^M" spike-algebra-13.
  istället för
  on "s^?" spike-algebra-13.
Eventuellt kan det vara okej att specificera mer nogrannt alla substitutionerna
när man använder ih.

Från beviset:
-- whole betyder hela termen. Det borde inte behövas fler parametrar.
-- jag skulle gärna vilja kunna ersätta "x : ys" med ?, men jag vet inte
-- hur svårt det skulle vara.
-- Detta är ju rätt najs ur ett checking-perspektiv. Vi kan parsea både
-- expressionen innan och efter och enskilt kolla så att de uppfyller kraven.
on ([0]s^(?)) -spike-algebra-zero-stack-spike; --"?" är wildcard. Detta är coolt om det funkar. Jag hittade inte en passande regel i figur 7.
on whole -def-unwindings n=n; --vet ej om argumentet till def-unwindings behövs
on ({repeat}d^¤) -dummy-ref-algebra-8;
-- tror att "on" är bra för att begränsa sökning av nästa steg (autocomplete)
let {xs = repeat^0 x} in any(M);
on repeat -def-unwindings base;
-- jag tror egentligen att första steget är bra, för då kan nästa rad autogenereras
-- Detta börjar likna ott rätt så rejält.
-- Testa att försöka uttrycka detta i Ott, och se vad det ger.
-- Ott har bara konkret syntax för variabler, så det blir krångligt.

Language notes, detailed:
[.] som hole

---- Ev senare utveckling
-latex pretty print
-snyggare vanlig pretty print
-kolla Agda (men svårt tror jag)

---Cake slice --
kolla en expression mot en regel i laws.sie

---- Att kolla i typecheckern ---
Typecheck 1
-Contexts används bara som argument
-Bindingar i InContext är deklarerade i bindings
-? används bara i on
är deklarerade?
   -alla variabler kan vara:
      -deklarerade som fria i början
        -bindningar i bindings får ej innehålla fria variabler
      -bundna till en letbindning som binder till termen den nämns i
         dvs M i (let G in M)
      -bundna till en konstruktor i en case-sats
      -bundna till en annan let-bindning i samma let-sats
      -bindna till en lambda som är relevant
   -any(M) -> M behöver vara deklarerad fri?
   -stack weights:
      -idents måste vara deklarerade fria?
        -alternativt bundna i bindings, men det är nog överkurs.
      -deklarera dessa fria innan bindings
      -bindings får ha fria viktvariabler
-Konstruktorer är deklarerade och fyllda
   - syntax för att deklarera dem saknas. (ngt i Bindings)
-> kolla bara bevis fram till <==here-symbolen.

-Korrekthet av bevis
  -Endast rätt relationssymbol får användas mellan varje term
  -Transformationerna måste stämma gentemot regeln
  -extra villkor om fria variabler osv måste respekteras
  -induktion: börja och sluta rätt
  -totalt sett: börja och sluta rätt
  -on-termen måste matcha mot föregående term
  -Senare: Regler:
    -Metavariabler som refereras till i regler finns
    -Regler finns deklarerade i laws.sie
    -Regler ska ha en matchande relationssymbol (specificera detta i laws.hs?)
    -Insättning av substitutionerna är korrekt

--- Desugaring ---
ingen vikt = [1,1]
inContext: G |- M <~> N == let G in M <~> let G in N
Reductions: show which term is the hole
bara en alts i CaseStm - eller kanske ta bort alts?
gör om variabler till ngn slags de brujin
  -sortera termer i Let?  -nej

-- Typcheckning av laws ---
index _i _j etc får endast användas på plats TODO fortsätt.
 -case A of B
 -case A of {B -> C}
 -case A of {alts, D -> E
