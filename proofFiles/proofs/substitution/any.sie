bindings {
G = { or = \a. \b. case a of
                     { True -> True
                     , False -> b
                     }
    };
}

-- Add gadgets
-- vi måste ha let in any(M) för att det ska funka. Just nu kör jag på
-- att any är fri. Observera att any är ett keyword, så det blir krångligt.
proposition: G free(any') |-
  \p. \xs. case xs of
            { [] -> False
            , y:ys -> let { py = p y
                          , anypys = any' p y ys}
                      in or py anypys}
   <~~>
  \p. \xs. [2]h^(case xs of
                   { [] -> s^False
                   , y:ys -> s^(let { z = @
                                    , py = p <> y
                                    , anypys = {z}d^(any' <> p <> y <> ys)}
                                in or <> py <> anypys)});
proof: -simple -single{
  -heap-spike-intro-lr ctx=(let G in (\p. \xs. [.]))
                       M= (case xs of
                                 { [] -> False
                                 , y:ys -> let { py = p y
                                               , anypys = any' p y ys}
                                           in or py anypys})
                       w=2;
  <~~> \p. \xs. [2]h^(case xs of
                      { [] -> False
                      , y:ys -> let { py = p y
                                    , anypys = any' p y ys}
                                in or py anypys});
  -stack-spike-intro-lr
    ctx = (let G in \p. \xs. [2]h^(case xs of
                      { [] -> False
                      , y:ys -> [.]}))
    M=(let { py = p y
                  , anypys = any' p y ys}
              in or py anypys)
    w=1;
  <~~> \p. \xs. [2]h^(case xs of
                        { [] -> False
                        , y:ys -> s^(let { py = p y
                                         , anypys = any' p y ys}
                                  in or py anypys)});
  -stack-spike-intro-lr
    ctx = (let G in \p. \xs. [2]h^(case xs of
                          { [] -> [.]
                          , y:ys -> s^(let { py = p y
                                           , anypys = any' p y ys}
                                    in or py anypys)}))
    M=False
    w=1;
  <~~> \p. \xs. [2]h^(case xs of
                        { [] -> s^False
                        , y:ys -> s^(let { py = p y
                                         , anypys = any' p y ys}
                                  in or py anypys)});
  -balloon-intro-untyped-lr
    ctx = (let G in \p. \xs. [2]h^(case xs of
                          { [] -> s^False
                          , y:ys -> s^(let { py = [.]
                                           , anypys = any' p y ys}
                                    in or py anypys)}))
    M=p x=y;
  <~~> \p. \xs. [2]h^(case xs of
                        { [] -> s^False
                        , y:ys -> s^(let { py = p <> y
                                         , anypys = any' p y ys}
                                  in or py anypys)});
  -balloon-intro-untyped-lr
    ctx=(let G in \p. \xs. [2]h^(case xs of
                          { [] -> s^False
                          , y:ys -> s^(let { py = p <> y
                                           , anypys = [.] y ys}
                                    in or py anypys)}))
    M=any' x=p;
  <~~> \p. \xs. [2]h^(case xs of
                        { [] -> s^False
                        , y:ys -> s^(let { py = p <> y
                                         , anypys = any' <> p y ys}
                                  in or py anypys)});
  -balloon-intro-untyped-lr
    ctx=(let G in \p. \xs. [2]h^(case xs of
                          { [] -> s^False
                          , y:ys -> s^(let { py = p <> y
                                           , anypys = [.] ys}
                                    in or py anypys)}))
    M=(any' <> p) x=y;
  <~~> \p. \xs. [2]h^(case xs of
                        { [] -> s^False
                        , y:ys -> s^(let { py = p <> y
                                         , anypys = any' <> p <> y ys}
                                     in or py anypys)});
  -balloon-intro-untyped-lr
    ctx=(let G in \p. \xs. [2]h^(case xs of
                          { [] -> s^False
                          , y:ys -> s^(let { py = p <> y
                                           , anypys = [.]}
                                       in or py anypys)}))
    M=(any' <> p <> y) x=ys;
  <~~> \p. \xs. [2]h^(case xs of
                        { [] -> s^False
                        , y:ys -> s^(let { py = p <> y
                                         , anypys = any' <> p <> y <> ys}
                                     in or py anypys)});
  -let-flatten-rl
    ctx=(let G in \p. \xs. [2]h^(case xs of
                                   { [] -> s^False
                                   , y:ys -> s^([.])}))
    G1=let {anypys = any' <> p <> y <> ys}
    G2=let {py = p<> y}
    M=(or py anypys);
  <~>  \p. \xs. [2]h^(case xs of
                        { [] -> s^False
                        , y:ys -> s^(let {anypys = any' <> p <> y <> ys}
                                     in let {py = p <> y}
                                        in or py anypys)});
  -dummy-bind-intro-lr
    ctx=(let G in \p. \xs. [2]h^(case xs of
                                   { [] -> s^False
                                   , y:ys -> s^([.])}))
    x=anypys
    M=(any' <> p <> y <> ys)
    N=(let {py = p <> y}
       in or py anypys)
    z=z;
  <~~> \p. \xs. [2]h^(case xs of
                        { [] -> s^False
                        , y:ys -> s^(let { z=@
                                         , anypys = {z}d^(any' <> p <> y <> ys)}
                                     in let {py = p <> y}
                                        in or py anypys)});
  -let-flatten-lr
    ctx= (let G in \p. \xs. [2]h^(case xs of
                          { [] -> s^False
                          , y:ys -> s^([.])}))
    G1=let { z=@, anypys = {z}d^(any' <> p <> y <> ys)}
    G2=let {py = p <> y}
    M=(or py anypys);
  <~>  \p. \xs. [2]h^(case xs of
                        { [] -> s^False
                        , y:ys -> s^(let { z=@
                                         , anypys = {z}d^(any' <> p <> y <> ys)
                                         , py = p <> y}
                                     in or py anypys)});
  -balloon-intro-untyped-lr
    ctx = (let G in \p. \xs. [2]h^(case xs of
                          { [] -> s^False
                          , y:ys -> s^(let { z=@
                                           , py = p <> y
                                           , anypys = {z}d^(any' <> p <> y <> ys)}
                                       in [.] anypys)}))
    M=or x=py;
  <~~> \p. \xs. [2]h^(case xs of
                        { [] -> s^False
                        , y:ys -> s^(let { z=@
                                         , py = p <> y
                                         , anypys = {z}d^(any' <> p <> y <> ys)}
                                     in or <> py anypys)});
  -balloon-intro-untyped-lr
    ctx = (let G in \p. \xs. [2]h^(case xs of
                          { [] -> s^False
                          , y:ys -> s^(let { z=@
                                           , py = p <> y
                                           , anypys = {z}d^(any' <> p <> y <> ys)}
                                       in [.])}))
    M=(or <> py) x=anypys;
  <~~> \p. \xs. [2]h^(case xs of
                        { [] -> s^False
                        , y:ys -> s^(let { z=@
                                         , py = p <> y
                                         , anypys = {z}d^(any' <> p <> y <> ys)}
                                     in or <> py <> anypys)});
  }
  qed;
